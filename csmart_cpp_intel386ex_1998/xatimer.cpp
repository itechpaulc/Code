


/////////////////////////////////////////////////////////////////////////////
//
//
//    $Header:      $
//    $Log:         $
//
//
//    Author : Paul Calinawan        January 1998
//
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//    NOTE:
//
//    This document contains CONFIDENTIAL and proprietary information
//    which is the property of Graphics Microsystems, Inc. It may not
//    be copied or transmitted in whole or in part by any means to any
//    media without Graphics Microsystems Inc's prior written permission.
//
/////////////////////////////////////////////////////////////////////////////



#include "xatimer.h"



//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
//  XAxisTimer
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
//  HeadMachinesManager
//
//      - public interface functions :
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////


//////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////

void
XAxisTimer::SetXAxisTimeOut(WORD xTimeOut)
{
    xAxisTimeOut = xTimeOut;
}

//////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////

BOOL
XAxisTimer::IsXAxisTimerExpired(void)
{
    return  xAxisTimerExpired;
}


//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
// XAxisTimer - private helper functions
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////




//////////////////////////////////////////////////
//
// XAxisTimer - RESPONSE ENTRIES
//
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// State Transition Matrices
//
//////////////////////////////////////////////////

STATE_TRANSITION_MATRIX(XAxisTimer, _XAT_IDLE)
    EV_HANDLER(StartXAxisTimer, XAT_h1)
STATE_TRANSITION_MATRIX_END;

STATE_TRANSITION_MATRIX(XAxisTimer, _XAT_WAITING_FOR_X_TIMER_TO_EXPIRE)
    EV_HANDLER(TimeOut, XAT_h2),
    EV_HANDLER(CancelXAxisTimer, XAT_h3)
STATE_TRANSITION_MATRIX_END;



//////////////////////////////////////////////////
//
// Matrix Table
//
//////////////////////////////////////////////////

DEFINE_RESPONSE_TABLE_ENTRY(XAxisTimer)
    STATE_MATRIX_ENTRY(_XAT_IDLE),
    STATE_MATRIX_ENTRY(_XAT_WAITING_FOR_X_TIMER_TO_EXPIRE)
RESPONSE_TABLE_END;


//////////////////////////////////////////////////
//
// Static Member Definitions
//
//////////////////////////////////////////////////

WORD    XAxisTimer::xAxisTimeOut = 0x0000;

BOOL    XAxisTimer::xAxisTimerExpired = TRUE;

WORD    XAxisTimer::errorCount = 0;



//////////////////////////////////////////////////
//
// XAxisTimer - Constructors, Destructors
//
//////////////////////////////////////////////////

XAxisTimer::XAxisTimer(BYTE sMsysID)
    :StateMachine(sMsysID)
{
    ASSIGN_RESPONSE_TABLE();

    SetCurrState(XAT_IDLE);
}

XAxisTimer::~XAxisTimer(void) { }


WORD    XAxisTimer::GetErrorCount(void) {

    return  XAxisTimer::errorCount;
}



//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
// XAxisTimer - private EXIT PROCEDURES
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// Message: Start X Axis Timer
//
//////////////////////////////////////////////////

WORD
XAxisTimer::XAT_h1(void) {

    // Get the data from the message

    xAxisTimeOut = (WORD)(GetCurrEvent().msgData1);

        // Make sure timeout has value

        if(xAxisTimeOut != 0)
        {
               StartHiPriorityTimer(MSEC(xAxisTimeOut));

                xAxisTimerExpired = FALSE;

            return  XAT_WAITING_FOR_X_TIMER_TO_EXPIRE;
        }

        xAxisTimerExpired = TRUE;

        // Send Expired Message to MTRC

        SendHiPrMsg(MotorCommID, XAxisTimerExpired);

    return  XAT_IDLE;
}


//////////////////////////////////////////////////
//
// Message : Kernel-TimeOut
//
//////////////////////////////////////////////////

WORD
XAxisTimer::XAT_h2(void) {

        xAxisTimerExpired = TRUE;

        // Send Expired Message to MTRC

        SendHiPrMsg(MotorCommID, XAxisTimerExpired);

    return  XAT_IDLE;
}


//////////////////////////////////////////////////
//
//  Message : Cancel X Axis Timer
//
//////////////////////////////////////////////////

WORD
XAxisTimer::XAT_h3(void)
{
        xAxisTimerExpired = TRUE;

        CancelTimer();

    return  XAT_IDLE;
}


