


/////////////////////////////////////////////////////////////////////////////
//
//
//    $Header:      $
//    $Log:         $
//
//
//    Author : Paul Calinawan        January 1998
//
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//    NOTE:
//
//    This document contains CONFIDENTIAL and proprietary information
//    which is the property of Graphics Microsystems, Inc. It may not
//    be copied or transmitted in whole or in part by any means to any
//    media without Graphics Microsystems Inc's prior written permission.
//
/////////////////////////////////////////////////////////////////////////////



#include "yatimer.h"



//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
//  YAxisTimer
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
//  YAxisTimer
//
//      - public interface functions :
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////


//////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////

void
YAxisTimer::SetYAxisTimeOut(WORD yTimeOut)
{
    yAxisTimeOut = yTimeOut;
}

//////////////////////////////////////////////////
//
//
//
//////////////////////////////////////////////////

BOOL
YAxisTimer::IsYAxisTimerExpired(void)
{
    return  yAxisTimerExpired;
}


//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
// YAxisTimer - private helper functions
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////




//////////////////////////////////////////////////
//
// YAxisTimer - RESPONSE ENTRIES
//
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// State Transition Matrices
//
//////////////////////////////////////////////////

STATE_TRANSITION_MATRIX(YAxisTimer, _YAT_IDLE)
    EV_HANDLER(StartYAxisTimer, YAT_h1)
STATE_TRANSITION_MATRIX_END;

STATE_TRANSITION_MATRIX(YAxisTimer, _YAT_WAITING_FOR_Y_TIMER_TO_EXPIRE)
    EV_HANDLER(TimeOut, YAT_h2),
    EV_HANDLER(CancelYAxisTimer, YAT_h3)
STATE_TRANSITION_MATRIX_END;



//////////////////////////////////////////////////
//
// Matrix Table
//
//////////////////////////////////////////////////

DEFINE_RESPONSE_TABLE_ENTRY(YAxisTimer)
    STATE_MATRIX_ENTRY(_YAT_IDLE),
    STATE_MATRIX_ENTRY(_YAT_WAITING_FOR_Y_TIMER_TO_EXPIRE)
RESPONSE_TABLE_END;


//////////////////////////////////////////////////
//
// Static Member Definitions
//
//////////////////////////////////////////////////

WORD    YAxisTimer::yAxisTimeOut = 0x0000;

BOOL    YAxisTimer::yAxisTimerExpired = TRUE;

WORD    YAxisTimer::errorCount = 0;



//////////////////////////////////////////////////
//
// YAxisTimer - Constructors, Destructors
//
//////////////////////////////////////////////////

YAxisTimer::YAxisTimer(BYTE sMsysID)
    :StateMachine(sMsysID)
{
    ASSIGN_RESPONSE_TABLE();

    SetCurrState(YAT_IDLE);
}

YAxisTimer::~YAxisTimer(void) { }


WORD    YAxisTimer::GetErrorCount(void) {

    return  YAxisTimer::errorCount;
}



//////////////////////////////////////////////////
//////////////////////////////////////////////////
//
// YAxisTimer - private EXIT PROCEDURES
//
//////////////////////////////////////////////////
//////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// Message: Start Y Axis Timer
//
//////////////////////////////////////////////////

WORD
YAxisTimer::YAT_h1(void) {

    // Get the data from the message

    yAxisTimeOut = (WORD)(GetCurrEvent().msgData1);

        // Make sure timeout has value

        if(yAxisTimeOut != 0)
        {
                StartHiPriorityTimer(MSEC(yAxisTimeOut));

                yAxisTimerExpired = FALSE;

            return  YAT_WAITING_FOR_Y_TIMER_TO_EXPIRE;
        }

        yAxisTimerExpired = TRUE;

        // Send Expired Message to MTRC

        SendHiPrMsg(MotorCommID, YAxisTimerExpired);

    return  YAT_IDLE;
}


//////////////////////////////////////////////////
//
// Message : Kernel-TimeOut
//
//////////////////////////////////////////////////

WORD
YAxisTimer::YAT_h2(void) {

        yAxisTimerExpired = TRUE;

        // Send Expired Message to MTRC

        SendHiPrMsg(MotorCommID, YAxisTimerExpired);

    return  YAT_IDLE;
}


//////////////////////////////////////////////////
//
//  Message : Cancel Y Axis Timer
//
//////////////////////////////////////////////////

WORD
YAxisTimer::YAT_h3(void)
{
        yAxisTimerExpired = TRUE;

        CancelTimer();

    return  YAT_IDLE;
}


